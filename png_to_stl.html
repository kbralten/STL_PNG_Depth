<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth Map to STL Converter</title>
    <!-- Replaced Tailwind with a small custom CSS to avoid CDN and production warnings -->
    <style>
        :root{
            --bg: #111827; /* gray-900 */
            --panel: #1f2937; /* gray-800 */
            --muted: #9ca3af; /* gray-400 */
            --accent: #6366f1; /* indigo-500 */
            --accent-hover: #4f46e5; /* indigo-600 */
            --green: #16a34a; /* green-600 */
            --green-hover: #15803d; /* green-700 */
            --card-shadow: 0 10px 15px rgba(0,0,0,0.4);
            font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
        }
        html,body{height:100%;margin:0;background:var(--bg);color:#e5e7eb;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
        .container{max-width:1100px;margin:0 auto;padding:1rem}
        @media(min-width:768px){.container{padding:2rem}}
        header{text-align:center;margin-bottom:2rem}
        h1{font-size:2rem;margin:0}
        @media(min-width:1024px){h1{font-size:3rem}}
        p{color:var(--muted);margin-top:.5rem}

        .grid{display:grid;grid-template-columns:1fr;gap:2rem}
        @media(min-width:1024px){.grid{grid-template-columns:320px 1fr}}

        .panel{background:var(--panel);padding:1.5rem;border-radius:0.5rem;box-shadow:var(--card-shadow);display:flex;flex-direction:column;gap:1.25rem}
        .panel h2,.panel h3{margin:0;color:#fff}

        .file-input-label{display:inline-block;width:100%;background:var(--accent);color:white;font-weight:700;padding:.75rem;border-radius:.5rem;text-align:center;cursor:pointer;box-shadow:0 6px 12px rgba(99,102,241,0.12);transition:transform .14s ease,background .14s ease}
        .file-input-label:hover{transform:translateY(-3px);background:var(--accent-hover)}
        input[type=file]{display:none}
        #file-name{font-size:.9rem;color:var(--muted);text-align:center;margin-top:.5rem}

        .range-row{display:flex;flex-direction:column;gap:.25rem}
        input[type=range]{width:100%}
        label.block{font-weight:600;color:#e5e7eb}

        .checkbox-row{display:flex;align-items:center;gap:.5rem}

        .download-btn{width:100%;background:var(--green);color:white;font-weight:700;padding:.75rem;border-radius:.5rem;cursor:pointer;border:none;display:inline-flex;align-items:center;justify-content:center}
        .download-btn:disabled{background:#4b5563;cursor:not-allowed;opacity:.9}
        .download-btn:hover:enabled{background:var(--green-hover)}

        .preview{background:var(--panel);padding:.5rem;border-radius:.5rem;min-height:400px;position:relative}
    /* screen-reader only text */
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
        @media(min-width:768px){.preview{min-height:600px}}
        #preview-canvas{width:100%;height:100%;display:block;border-radius:.5rem}
        #placeholder-text{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:1.05rem}
        #spinner{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(31,41,55,0.75);border-radius:.5rem}
        #spinner.hidden{display:none}

        /* Simple utility classes used in the markup to avoid touching structure */
        .text-center{text-align:center}
        .mb-8{margin-bottom:2rem}
        .mt-2{margin-top:.5rem}
        .font-bold{font-weight:700}
        .rounded-lg{border-radius:.5rem}
        .shadow-xl{box-shadow:var(--card-shadow)}
        .flex{display:flex}
        .flex-col{flex-direction:column}
        .items-end{align-items:flex-end}
        .mt-4{margin-top:1rem}
        .pt-4{padding-top:1rem}
    </style>
    <!-- Google Fonts for a modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for the file input */
        .file-input-label {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        /* Style for the 3D canvas */
        #preview-canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 0.5rem;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }
    </style>
</head>
    <body>

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-white">Depth Map to 3D Model</h1>
            <p class="text-gray-400 mt-2">Upload a black & white depth map to generate a 3D model and export it as an STL file.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Controls Section -->
            <div class="lg:col-span-1 bg-gray-800 p-6 rounded-lg shadow-xl flex flex-col space-y-6">
                <div>
                    <h2 class="text-2xl font-semibold mb-4 text-white">Controls</h2>
                    <!-- File Upload -->
                    <div>
                        <label for="image-upload" class="file-input-label">
                            <!-- Elegant upload icon + text -->
                            <svg aria-hidden="true" width="20" height="20" viewBox="0 0 24 24" fill="none" style="vertical-align:middle;margin-right:.5rem;">
                                <path d="M12 3v12" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M8 7l4-4 4 4" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                                <rect x="4" y="15" width="16" height="4" rx="1" fill="currentColor" opacity="0.08"/>
                            </svg>
                            <span style="vertical-align:middle;">Upload Depth Map</span>
                            <span class="sr-only">Upload a depth map image file</span>
                        </label>
                        <input type="file" id="image-upload" class="hidden" accept="image/*">
                        <p id="file-name" class="text-sm text-gray-400 mt-2 text-center">No file selected.</p>
                    </div>
                </div>

                <!-- Model Settings -->
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-white border-t border-gray-700 pt-4">Model Settings</h3>
                    <!-- Height Scale -->
                    <div class="space-y-2">
                        <label for="height-scale" class="block font-medium">Height Scale: <span id="height-scale-value">50</span></label>
                        <input type="range" id="height-scale" min="1" max="200" value="50" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                     <!-- Base Thickness -->
                    <div class="space-y-2 mt-4">
                        <label for="base-thickness" class="block font-medium">Base Thickness: <span id="base-thickness-value">5</span></label>
                        <input type="range" id="base-thickness" min="0" max="50" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <!-- Invert Height -->
                    <div class="flex items-center mt-4">
                        <input type="checkbox" id="invert-height" class="h-4 w-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500">
                        <label for="invert-height" class="ml-2 block text-sm font-medium">Invert Height</label>
                    </div>
                    <!-- Simplify Ratio -->
                    <div class="space-y-2 mt-4">
                        <label for="simplify-ratio" class="block font-medium">Simplify (Keep %): <span id="simplify-ratio-value">100</span></label>
                        <input type="range" id="simplify-ratio" min="1" max="100" value="100" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>

                <!-- Export Button -->
                <div class="flex-grow flex items-end">
                    <button id="download-stl" class="download-btn" disabled aria-disabled="true">
                        <!-- Elegant download icon + text -->
                        <svg aria-hidden="true" width="18" height="18" viewBox="0 0 24 24" fill="none" style="vertical-align:middle;margin-right:.5rem;">
                            <path d="M12 21V9" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M8 15l4 4 4-4" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
                            <rect x="4" y="4" width="16" height="4" rx="1" fill="currentColor" opacity="0.06"/>
                        </svg>
                        <span style="vertical-align:middle;">Download STL</span>
                        <span class="sr-only">Download the generated STL file</span>
                    </button>
                </div>
            </div>

            <!-- 3D Preview Section -->
            <div class="lg:col-span-2 bg-gray-800 p-2 rounded-lg shadow-xl min-h-[400px] md:min-h-[600px] relative">
                 <canvas id="preview-canvas"></canvas>
                 <div id="placeholder-text" class="absolute inset-0 flex items-center justify-center text-gray-500 text-lg">
                    <p>Upload an image to see the 3D preview</p>
                 </div>
                 <!-- Spinner Element -->
                 <div id="spinner" class="absolute inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75 rounded-lg hidden">
                    <svg class="animate-spin h-12 w-12 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                 </div>
            </div>
        </main>
    </div>

    <!-- three.js and controls -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/",
                "meshoptimizer": "https://cdn.jsdelivr.net/npm/meshoptimizer@0.20.0/meshopt_simplifier.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';
        import { MeshoptSimplifier } from 'meshoptimizer';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls, mesh;
        let originalImageData = null;

        const canvas = document.getElementById('preview-canvas');
        const placeholderText = document.getElementById('placeholder-text');
        const spinner = document.getElementById('spinner');
        const imageUpload = document.getElementById('image-upload');
        const fileNameDisplay = document.getElementById('file-name');
        const downloadButton = document.getElementById('download-stl');
        const heightScaleSlider = document.getElementById('height-scale');
        const heightScaleValue = document.getElementById('height-scale-value');
        const baseThicknessSlider = document.getElementById('base-thickness');
        const baseThicknessValue = document.getElementById('base-thickness-value');
        const invertHeightCheckbox = document.getElementById('invert-height');
        const simplifySlider = document.getElementById('simplify-ratio');
        const simplifyValue = document.getElementById('simplify-ratio-value');

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1f2937);
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 150, 200);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 200, 100);
            scene.add(directionalLight);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            if (mesh) {
                updateCameraToObject(mesh);
            }
        }
        
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            fileNameDisplay.textContent = file.name;
            const reader = new FileReader();
            reader.onload = (e) => {
                const image = new Image();
                image.onload = () => {
                    originalImageData = image;
                    generateModel();
                    placeholderText.style.display = 'none';
                    downloadButton.disabled = false;
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        heightScaleSlider.addEventListener('input', () => { heightScaleValue.textContent = heightScaleSlider.value; });
        baseThicknessSlider.addEventListener('input', () => { baseThicknessValue.textContent = baseThicknessSlider.value; });
        simplifySlider.addEventListener('input', () => { simplifyValue.textContent = simplifySlider.value; });

        heightScaleSlider.addEventListener('change', () => { if (originalImageData) generateModel(); });
        baseThicknessSlider.addEventListener('change', () => { if (originalImageData) generateModel(); });
        simplifySlider.addEventListener('change', () => { if (originalImageData) generateModel(); });
        
        invertHeightCheckbox.addEventListener('change', () => {
            if (originalImageData) generateModel();
        });
        
        downloadButton.addEventListener('click', () => {
            if (!mesh) return;
            const exporter = new STLExporter();
            const result = exporter.parse(mesh, { binary: true });
            const blob = new Blob([result], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            link.href = URL.createObjectURL(blob);
            link.download = 'model.stl';
            link.click();
            document.body.removeChild(link);
        });

        // --- Core Logic ---
        async function generateModel() {
            if (!originalImageData) return;

            spinner.classList.remove('hidden');
            await new Promise(resolve => setTimeout(resolve, 0));

            try {
                const heightScale = parseFloat(heightScaleSlider.value);
                const baseThickness = parseFloat(baseThicknessSlider.value);
                const invert = invertHeightCheckbox.checked;
                const simplifyRatio = parseFloat(simplifySlider.value) / 100;

                const tempCanvas = document.createElement('canvas');
                const context = tempCanvas.getContext('2d');
                tempCanvas.width = originalImageData.width;
                tempCanvas.height = originalImageData.height;
                context.drawImage(originalImageData, 0, 0);
                const imageData = context.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;

                if (mesh) {
                    scene.remove(mesh);
                    if(mesh.geometry) mesh.geometry.dispose();
                    if(mesh.material) mesh.material.dispose();
                }

                // --- FIX: Build a single, solid, manifold geometry from scratch ---
                const vertices = [];
                const indices = [];

                // Create vertices
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const pixelIndex = (y * width + x) * 4;
                        const grayscale = data[pixelIndex] / 255.0;
                        const zValue = (invert ? (1.0 - grayscale) : grayscale) * heightScale;
                        
                        // Top vertex
                        vertices.push(x - (width-1)/2, -(y - (height-1)/2), zValue);
                        // Bottom vertex
                        vertices.push(x - (width-1)/2, -(y - (height-1)/2), -baseThickness);
                    }
                }

                // Create faces (indices)
                for (let y = 0; y < height - 1; y++) {
                    for (let x = 0; x < width - 1; x++) {
                        const i = (y * width + x) * 2;
                        // Top face
                        indices.push(i, i + 2, i + 2 * width);
                        indices.push(i + 2, i + 2 * width + 2, i + 2 * width);
                        // Bottom face
                        indices.push(i + 1, i + 2 * width + 1, i + 3);
                        indices.push(i + 3, i + 2 * width + 1, i + 2 * width + 3);
                    }
                }

                // Create side faces
                for (let i = 0; i < width - 1; i++) {
                    const top = i * 2;
                    indices.push(top, top + 1, top + 2);
                    indices.push(top + 1, top + 3, top + 2);

                    const bottom = ((height - 1) * width + i) * 2;
                    indices.push(bottom, bottom + 2, bottom + 1);
                    indices.push(bottom + 1, bottom + 2, bottom + 3);
                }
                for (let i = 0; i < height - 1; i++) {
                    const left = (i * width + width - 1) * 2;
                    indices.push(left, left + 1, left + 2 * width);
                    indices.push(left + 1, left + 2 * width + 1, left + 2 * width);

                    const right = (i * width) * 2;
                    indices.push(right, right + 2 * width, right + 1);
                    indices.push(right + 1, right + 2 * width, right + 2 * width + 1);
                }

                const solidGeometry = new THREE.BufferGeometry();
                solidGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                solidGeometry.setIndex(indices);
                solidGeometry.computeVertexNormals();
                
                let finalGeometry = solidGeometry;
                
                // --- High-Speed Simplification with meshoptimizer ---
                if (finalGeometry && finalGeometry.index && simplifyRatio < 1.0) {
                    // meshoptimizer expects typed arrays and a specific argument order.
                    // Ensure positions are Float32Array and indices are Uint32Array (or Uint16Array if small).
                    const posAttr = finalGeometry.attributes.position;
                    const idxAttr = finalGeometry.index;

                    // Convert / copy to the expected typed arrays if necessary
                    const positions = (posAttr.array instanceof Float32Array)
                        ? posAttr.array
                        : new Float32Array(posAttr.array);

                    // meshopt requires indices to be a integer typed array. Use Uint32Array for generality.
                    const indicesArray = (idxAttr.array instanceof Uint32Array)
                        ? idxAttr.array
                        : new Uint32Array(idxAttr.array);

                    const currentTriangleCount = Math.floor(indicesArray.length / 3);
                    const targetTriangleCount = Math.max(1, Math.floor(currentTriangleCount * simplifyRatio));
                    const targetIndexCount = targetTriangleCount * 3;

                    // Call simplify with the expected signature:
                    // simplify(indices, vertex_positions, vertex_positions_stride, target_index_count, target_error)
                    const result = MeshoptSimplifier.simplify(
                        indicesArray,
                        positions,
                        posAttr.itemSize,
                        targetIndexCount,
                        0.02
                    );

                    // result is [newIndicesTypedArray, error]
                    const simplifiedIndices = result[0];

                    const simplifiedGeometry = new THREE.BufferGeometry();
                    // Reuse the positions attribute (it's already a buffer attribute). However, to be safe, create a new one referencing the same underlying array.
                    simplifiedGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), posAttr.itemSize));
                    simplifiedGeometry.setIndex(new THREE.BufferAttribute(simplifiedIndices, 1));
                    simplifiedGeometry.computeVertexNormals();

                    finalGeometry = simplifiedGeometry;
                }
                
                const material = new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
                mesh = new THREE.Mesh(finalGeometry, material);
                // The new geometry is already in the correct orientation
                // mesh.rotation.x = -Math.PI / 2; 
                
                scene.add(mesh);
                updateCameraToObject(mesh);
            } finally {
                spinner.classList.add('hidden');
            }
        }

        function updateCameraToObject(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const sphere = box.getBoundingSphere(new THREE.Sphere());
            const radius = sphere.radius;
            
            object.position.sub(center);

            const fov = camera.fov * (Math.PI / 180);
            const distance = Math.abs(radius / Math.sin(fov / 2));

            const direction = new THREE.Vector3(0.5, 0.4, 1).normalize();
            camera.position.copy(direction.multiplyScalar(distance));
            
            camera.near = 0.1;
            camera.far = distance + radius * 2;
            camera.updateProjectionMatrix();

            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        init();

    </script>
</body>
</html>
